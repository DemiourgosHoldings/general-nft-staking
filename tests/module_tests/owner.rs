use multiversx_sc::types::MultiValueEncoded;
use multiversx_sc_scenario::{managed_token_id, rust_biguint};
use nft_staking::{
    constants::ERR_COLLECTION_ALREADY_REGISTERED, owner::OwnerModule,
    staking_modules::staking_module_type::StakingModuleType, storage::score::ScoreStorageModule,
};

use crate::setup::{
    constants::{NO_ERR_MSG, POOL1_TOKEN_ID, POOL2_TOKEN_ID},
    types::new_nft_transfer,
    ContractSetup,
};

// test that this collection won't receive any of the primary rewards
// but will receive 100% of the secondary rewards generated by their subsidiary
#[test]
#[allow(deprecated)]
fn create_pool_successful() {
    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                sc.register_new_staking_pool(
                    managed_token_id!(POOL1_TOKEN_ID),
                    StakingModuleType::Bloodshed,
                );
            },
        )
        .assert_ok();
}

#[test]
#[allow(deprecated)]
fn create_pool_works_correctly_with_different_collections() {
    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                sc.register_new_staking_pool(
                    managed_token_id!(POOL1_TOKEN_ID),
                    StakingModuleType::Bloodshed,
                );
                sc.register_new_staking_pool(
                    managed_token_id!(POOL2_TOKEN_ID),
                    StakingModuleType::Nosferatu,
                );
            },
        )
        .assert_ok();
}

#[test]
#[allow(deprecated)]
fn create_pool_fails_for_existing_pool() {
    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                sc.register_new_staking_pool(
                    managed_token_id!(POOL1_TOKEN_ID),
                    StakingModuleType::Bloodshed,
                );
                sc.register_new_staking_pool(
                    managed_token_id!(POOL1_TOKEN_ID),
                    StakingModuleType::Bloodshed,
                );
            },
        )
        .assert_user_error(ERR_COLLECTION_ALREADY_REGISTERED);
}

#[test]
#[allow(deprecated)]
fn override_pool_type_successful() {
    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                sc.override_stake_pool_type(
                    managed_token_id!(POOL1_TOKEN_ID),
                    StakingModuleType::Bloodshed,
                );
            },
        )
        .assert_ok();
}

#[test]
#[allow(deprecated)]
fn set_base_asset_score_successful() {
    let score = 123456;

    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                sc.set_base_asset_score(
                    &managed_token_id!(POOL1_TOKEN_ID),
                    &StakingModuleType::All,
                    score,
                );
            },
        )
        .assert_ok();

    setup
        .b_mock
        .execute_query(&setup.contract_wrapper, |sc| {
            let q = sc
                .base_asset_score(&managed_token_id!(POOL1_TOKEN_ID), &StakingModuleType::All)
                .get();
            assert_eq!(score, q);
        })
        .assert_ok();
}

#[test]
#[allow(deprecated)]
fn set_nonce_asset_score_successful() {
    let nonce_score = 111111;

    let target_nonces = &[11, 12, 13, 14, 15u64];

    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                let mut nonces = MultiValueEncoded::new();
                for target_nonce in target_nonces.iter() {
                    nonces.push(*target_nonce);
                }

                sc.set_nonce_asset_score(
                    &managed_token_id!(POOL1_TOKEN_ID),
                    &StakingModuleType::All,
                    nonce_score,
                    nonces,
                );
            },
        )
        .assert_ok();

    setup
        .b_mock
        .execute_query(&setup.contract_wrapper, |sc| {
            for target_nonce in target_nonces.iter() {
                let q = sc
                    .nonce_asset_score(
                        &managed_token_id!(POOL1_TOKEN_ID),
                        *target_nonce,
                        &StakingModuleType::All,
                    )
                    .get();
                assert_eq!(q, nonce_score);
            }
        })
        .assert_ok();
}

#[test]
#[allow(deprecated)]
fn set_nonce_asset_score_by_range() {
    let nonce_score = 111111;

    let nonce_range_start = 11;
    let nonce_range_end = 15;

    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                sc.set_nonce_asset_score_by_range(
                    &managed_token_id!(POOL1_TOKEN_ID),
                    &StakingModuleType::All,
                    nonce_score,
                    nonce_range_start,
                    nonce_range_end,
                );
            },
        )
        .assert_ok();

    setup
        .b_mock
        .execute_query(&setup.contract_wrapper, |sc| {
            for nonce in nonce_range_start..=nonce_range_end {
                let q = sc
                    .nonce_asset_score(
                        &managed_token_id!(POOL1_TOKEN_ID),
                        nonce,
                        &StakingModuleType::All,
                    )
                    .get();
                assert_eq!(q, nonce_score);
            }
        })
        .assert_ok();
}

#[test]
#[allow(deprecated)]
fn set_full_set_score() {
    let score = 123456;

    let mut setup = ContractSetup::new(nft_staking::contract_obj);
    setup
        .b_mock
        .execute_tx(
            &setup.owner_address,
            &setup.contract_wrapper,
            &rust_biguint!(0),
            |sc| {
                sc.set_full_set_score(
                    &managed_token_id!(POOL1_TOKEN_ID),
                    &StakingModuleType::All,
                    score,
                );
            },
        )
        .assert_ok();

    setup
        .b_mock
        .execute_query(&setup.contract_wrapper, |sc| {
            let q = sc
                .full_set_score(&managed_token_id!(POOL1_TOKEN_ID), &StakingModuleType::All)
                .get();
            assert_eq!(score, q);
        })
        .assert_ok();
}
